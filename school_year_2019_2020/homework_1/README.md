# Домашно №1 - колекции

## Зад. 1

Да се напише функция ```group_by_f(f, lst)``` , която по подадени
функция - ```f``` и списък - ```lst``` групира елементите на списъка по стойността,
която връща ```f``` за всеки от тях. Резултатът от функцията трябва да бъде речник,
в който ключ - ```к``` е стойността върната от изпълнението на ```f``` над някой елемент от ```lst```
, а стойност е списък от всички елементи ```x``` от ```lst```, за които ```f(x) = k```.

Например:

```
>>> group_by_f(lambda a : a % 2 == 0, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
{False: [1, 3, 5, 7, 9], True: [2, 4, 6, 8, 10]}

>>> group_by_f(len, [[1], [7, 8], [1, 2, 3, 4], [4], ["random", "words"]])
{1: [[1], [4]], 2: [[7, 8], ['random', 'words']], 4: [[1, 2, 3, 4]]}

```

## Зад. 2

Лекарство се задава със наредена двойка от име (низ) и списък от активни съставки,
зададени като наредени двойки от име (низ) и количество в мг (цяло число).

Например:

```
>>>aspirin = ('aspirin', [('acetylsalicylic acid', 150), ('pain reliever', 100), ('triacetin', 50)])
```

Казваме, че лекарството A е по-силно от лекарството B, ако A има всички активни съставки
на B (евентуално и още други) в поне същите количества, като поне една от съставките
е в по-голямо количество.

1. Да се реализира функция ```is_stronger```, която по две дадени лекарства проверява дали първото е по-силно от второто.

    Например:

    ```
    >>> A = ("A", [("p", 5), ("q", 3)])
    >>> B = ("B", [("p", 4), ("q", 3)])
    >>> C = ("C", [("p", 3)])
    >>> is_stronger(A, B)
    True
    >>> is_stronger(B, A)
    False
    ```

2. Да се реализира функция ```least_stronger``` , която по лекарство ```A``` и списък от лекарства ```L``` намира името на лекарство ```B```,
     което е по-силно от ```A``` и сумата от разликите в количествата на общите съставки на ```B``` и ```A``` е възможно най-малка, или празният низ, ако такова няма.

     Например:

     ```
     >>> A = ("A", [("p", 5), ("q", 3)])
     >>> B = ("B", [("p", 4), ("q", 3)])
     >>> C = ("C", [("p", 3)])
     >>> D = ("D", [("p", 4.5), ("q", 3), ("r", 1)])
     >>> least_stronger(B, [A, C, D])
     ('A', [('p', 5), ('q', 3)])
     >>> least_stronger(A, [B, C, D])
     []
     ```

3. Да се реализира функция ```strong_relation```, която по списък от лекарства ```L``` връща списък от наредени двойки от лекарство и списък от имена на лекарства в L,
     които са по-силни от него.

     Например (A, B, C са същите):

    ```
    >>> l = [A, B, C]
    >>> l
    [('A', [('p', 5), ('q', 3)]), ('B', [('p', 4), ('q', 3)]), ('C', [('p', 3)])]
    >>> strong_relation(l)
    [(('A', [('p', 5), ('q', 3)]), []), (('B', [('p', 4), ('q', 3)]), ['A']), (('C', [('p', 3)]), ['A', 'B'])]
    ```

## Зад. 3

Музикален такт се описва с цяло число, задаващо броя ноти в него. Музикална партия наричаме последоваелност от тактове. Музикална партитура
наричаме списък от музикални партии с равен брой тактове.

1. Да се напише функция ```max_notes```, която приема като аргумент партитура ```P``` и връща максималния брой ноти в партия в дадена партитура.

    Например:

    ```
    >>> max_notes([[1, 2, 3], [2, 2, 2], [9, 7, 3]])
    19
    >>> max_notes([])
    0
    ```
2. Партия наричаме **доминираща** в такт с пореден номер **n**, ако в този такт има най-много ноти измежду всички тактове с номер **n**
в партитура.

    Например:
    <pre>
    [[1, 2, <b>2</b>], [4, 8, <b><u>6</u></b>], [3, 2, <b>4</b>]]
    </pre>
    Тук казваме, че втората партия ```[4, 8, 6]``` e доминираща в третия такт в тази партитура, тъй като 6 > 3 и 6 > 4, тоест втората партия
    съдържа най-много ноти в третия такт спрямо останалите партии.

    Да се напише функция ```leading```, която по дадена партитура намира номер(индекс - броим от 0) на партия, която е доминираща в максимален брой тактове.

        Например:

        ```
        >>> leading([[1, 10, 2], [2, 2, 2], [9, 7, 3]])
        2
        ```
    (Ако се окаже, че 2 партии са **доминиращи** в равен брой тактове, функцията да връща индекса на партията, която се намира на по-предна позиция
    в партитурата)

