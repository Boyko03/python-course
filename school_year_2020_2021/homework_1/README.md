# Обработка на структурирани логове

Представете си, че имате система, която записва в някаква база данни структурирани логове, т.е. съобщения от вида:


```python
{"timestamp": "2020-05-11T13:42:50", "status": "error", "countryISO2": "BG"}
```

Като всяко съобщение може да съдържа произволни ключове и стойности (т.е. възможните ключовете не са само тези три, показани в горния пример). Всички ключове ще са от тип string, докато за стойностите няма ограничение.

За улеснение, "базата данни" ще бъде обикновен Python списък, например валидна база данни би било"

```python
logs = [
    {"timestamp": "2020-05-11T13:42:50", "status": "error", "countryISO2": "BG"},
    {"timestamp": "2020-05-11T13:43:20", "status": "success", "countryISO2": "UK"},
    {"timestamp": "2020-05-11T13:44:30", "status": "success", "countryISO2": "NZ"},
]
```

Като хора, които поддържат тази система, бихме искали да можем да правим разнообразни анализи върху логовете ѝ.

## Функция за филтриране

Напишете функция със следната сигнатура:

```python
def filter_logs(logs, key, value):
    # the implementation is up to you
    ...
```

Функцията трябва да приема списък от лог съобщения като първи аргумент, име на ключ като втори и някаква стойност като трети. Резултатът трябва да бъде списък с всички съобщения, за които стойността асоциирана с подадения ключ е равна на подадената стойност. Примери:

```python
filter_logs(logs, "status", "success")
=>  [{'timestamp': '2020-05-11T13:43:20', 'status': 'success', 'countryISO2': 'UK'}, {'timestamp': '2020-05-11T13:44:30', 'status': 'success', 'countryISO2': 'NZ'}]

filter_logs(logs, "countryISO2", "BG")
=> [{'timestamp': '2020-05-11T13:42:50', 'status': 'error', 'countryISO2': 'BG'}]
```

## Top N

Дефинирайте функция:

```python
def top(logs, key, count):
    # Имплементирай ме
    ...
```

На функцията се подават списък от логове, ключ и бройка **N** и тя връща речник със **N**-те най-често срещани стойности за този ключ. Например:

```python
top(logs, "status", 1)
=> {'success': 2}

top(logs, "status", 3)
=> {'success': 2, 'error': 1}
```

## Сложно филтриране

Дефинирайте функция:

```python
def complex_filter(logs, filter_params):
    # Имплементация
    ...
```

Функцията приема списък от съобщения и речник с двойки `ключ: стойност` и връща само съобщенията, които отговарят на всички условия от речника. Тоест, можем да приложим няколко филтъра едновременно върху списъка с логове. Няколко примера, за да стане по-ясно:


```python
# Да вземем само съобщенията, които имат status = "success" И countryISO2 = "NZ"
complex_filter(logs, {"status": "success", "countryISO2": "NZ"})
=> [{'timestamp': '2020-05-11T13:44:30', 'status': 'success', 'countryISO2': 'NZ'}]

# Да вземем само съобщенията, които имат status = "error" И countryISO2 = "UK"
complex_filter(logs, {"status": "error", "countryISO2": "UK"})
=> []

# Да вземем само съобщенията, които имат status = "error"
complex_filter(logs, {"status": "error"})
=> [{"timestamp": "2020-05-11T13:42:50", "status": "error", "countryISO2": "BG"}]

# Ако речника с филтри е празен, всички съобщения отговарят на "условията"
complex_filter(logs, {})
=> [
    {"timestamp": "2020-05-11T13:42:50", "status": "error", "countryISO2": "BG"},
    {"timestamp": "2020-05-11T13:43:20", "status": "success", "countryISO2": "UK"},
    {"timestamp": "2020-05-11T13:44:30", "status": "success", "countryISO2": "NZ"},
]
```

